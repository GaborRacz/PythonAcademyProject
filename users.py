import os
import re
import datetime
import storage_utils


class User(object):
    """Managing of user data

    The data of the users are stored in the users directory.

    The file names are the identifiers of the users.

    A new user identifier is generated by finding the maximal value of the identifiers and increasing by one.

    The fields of a user object stored in the text file line-by-line as:

        first_name
        family_name
        birth
        email
        password

    """

    def __init__(self, first_name, family_name, birth, email, password):
        self._first_name = first_name
        self._family_name = family_name
        self._birth = birth
        self._email = email
        self._password = password

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        self._first_name = value.title()

    @property
    def family_name(self):
        return self._family_name

    @family_name.setter
    def family_name(self, value):
        self._family_name = value.title()

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = datetime.date(value[0], value[1], value[2])

    @property
    def email(self):
        return self._email

    @email.setter
    def email(self, value):
        match = re.match('^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$', value)
        if match is None:
            raise ValueError("Invalid email format!")
        else:
            self.email = value

    @property
    def password(self):
        return self._password

    @password.setter
    def password(self, value):
        if len(value) < 4:
            raise ValueError("The password should be at least 4 characters long.")
        else:
            self._password = value


class Role(object):
    """
    Represents the roles of the users
    The only viable roles are admin, manager author reviewer and visitor
    """

    def __init__(self, role):
        if role in ['admin', 'manager', 'author', 'reviewer', 'visitor']:
            self._role = role
        else:
            raise ValueError('The "{}" is an invalid role!'.format(role))

    def valid_role(self):
        """
        Checks if the role is value
        :return: string of the role
        """
        return self._role


class RoleManager(object):
    """Manage the user roles which are stored in a text file."""

    def __init__(self, role_location):
        self._role_location = role_location
        self.roles = {}

    def read_roles(self):
        """
        Read the roles from the roles.ini file, and stores them in a dict
        :return: dict of the users and their roles
        """
        stored_roles = {}
        with open(os.path.join(self._role_location, "roles.txt")) as role_file:
            for line in role_file:
                (key, values) = line.strip().split(":")
                for value in values.strip().split(","):
                    if key in stored_roles:
                        stored_roles[key].append(value)
                    else:
                        stored_roles[key] = [value]
        return stored_roles

    def add_role(self, user_id, role):
        """
        Add a role to a user by ID
        :param user_id: unique ID of the user
        :param role: string of the role to be added to the user
        """
        split_roles = role.split(",")
        for i in split_roles:
            if user_id in self.roles:
                if i not in self.roles[user_id]:
                    self.roles[str(user_id)].append(i)
                else:
                    raise ValueError("Duplicate role.")
            else:
                self.roles[str(user_id)] = [i]

    def remove_role(self, user_id, role):
        """
        Remove a role from the specified user
        :param user_id: unique ID of the user
        :param role: specified role to be removed from the user
        """
        self.roles = self.read_roles()
        if user_id in self.roles:
            if role in self.roles[user_id]:
                self.roles[user_id].remove(role)
                self.write_roles()
            else:
                raise ValueError("No {} role for {} user.".format(role, user_id))
        else:
            raise KeyError("No {} user in roles.txt".format(user_id))

    def write_roles(self):
        """Write roles to the roles.txt."""
        with open(os.path.join(self._role_location, "roles.txt"), "w") as role_file:
            for user_id in self.roles:
                role_file.write("{}: {}\n".format(user_id, ",".join(self.roles[user_id])))

    def check_role_file(self):
        """Check if the roles.txt file has a correct format"""
        pattern = re.compile(".+[^ ]: .+")
        with open(os.path.join(self._role_location, "roles.txt")) as role_file:
            for line in role_file:
                if pattern.match(line) is None:
                    raise ValueError("The roles.txt file's format is invalid.")


class UserManager(object):
    """Manage user objects"""

    def __init__(self, storage_location):
        self._storage_location = storage_location

    def save_user(self, user_id, user):
        """Save user to file"""
        with open(os.path.join(self._storage_location, str(user_id)), 'w') as user_file:
            user_file.write(user.first_name + '\n')
            user_file.write(user.family_name + '\n')
            user_file.write(str(user.birth) + '\n')
            user_file.write(user.email + '\n')
            user_file.write(user.password + '\n')

    def load_user(self, user_id):
        """Load user from file"""
        with open(os.path.join(self._storage_location, user_id)) as user_file:
            first_name = user_file.readline().rstrip('\n')
            family_name = user_file.readline().rstrip('\n')
            birth = user_file.readline().rstrip('\n')
            email = user_file.readline().rstrip('\n')
            password = user_file.readline().rstrip('\n')
        user = User(first_name, family_name, birth, email, password)
        return user

    def add_user(self, user):
        """
        Create the ID of the user, calls the save_user method
        :param user: User type object to be added to the users
        :return: unique ID of the user
        """
        user_id = storage_utils.get_next_id(self._storage_location)
        self.save_user(user_id, user)
        return user_id

    def update_user(self, user_id, user):
        """
        Remove and then re-create the user
        :param user_id: unique ID generated by storage_utils
        :param user: a User type object
        """
        self.remove_user(user_id)
        self.save_user(user_id, user)

    def remove_user(self, user_id):
        """
        Delete the user from the repository/users folder
        :param user_id: unique ID generated by storage_utils
        """
        user_file_path = os.path.join(self._storage_location, user_id)
        if os.path.exists(user_file_path):
            os.remove(user_file_path)
        else:
            raise ValueError('The user id {} does not exist!'.format(user_id))

    def find_user_by_id(self, user_id):
        """
        Search for the user in the repository based on ID
        :param user_id: unique ID generated by storage_utils
        :return: User type object, or raise ValueError
        """
        user_file_path = os.path.join(self._storage_location, user_id)
        if os.path.exists(user_file_path):
            user = self.load_user(user_id)
            return user
        else:
            raise ValueError('The user id {} does not exist!'.format(user_id))

    def count_users(self):
        """
        Calculates the number of users in the repository
        :return: # of users
        """
        return len(os.listdir(self._storage_location))

    def add_role(self, user_id, role):
        """
        Add a specified role or list of roles to the user
        :param user_id: unique ID generated by storage_utils
        :param role: specific role to be added to the user using RoleManager
        """
        RoleManager(self._storage_location).add_role(user_id, role)

    def remove_role(self, user_id, role):
        """
        Remove a specified role from a specified user
        :param user_id: unique ID generated by storage_utils
        :param role: specific role to be removed from the user using RoleManager
        """
        RoleManager(self._storage_location).remove_role(user_id, role)